## 2975. Maximum Square Area by Removing Fences From a Field

## C++

```
class Solution {
 public:
  int maximizeSquareArea(int m, int n, vector<int>& hFences,
                         vector<int>& vFences) {
    constexpr int kMod = 1'000'000'007;

    hFences.push_back(1);
    hFences.push_back(m);
    vFences.push_back(1);
    vFences.push_back(n);

    ranges::sort(hFences);
    ranges::sort(vFences);

    const unordered_set<int> hGaps = getGaps(hFences);
    const unordered_set<int> vGaps = getGaps(vFences);
    int maxGap = -1;

    for (const int hGap : hGaps)
      if (vGaps.contains(hGap))
        maxGap = max(maxGap, hGap);

    return maxGap == -1 ? -1 : static_cast<long>(maxGap) * maxGap % kMod;
  }

 private:
  unordered_set<int> getGaps(const vector<int>& fences) {
    unordered_set<int> gaps;
    for (int i = 0; i < fences.size(); ++i)
      for (int j = 0; j < i; ++j)
        gaps.insert(fences[i] - fences[j]);
    return gaps;
  }
};
```

## Python3

```
class Solution:
  def maximizeSquareArea(
      self,
      m: int,
      n: int,
      hFences: list[int],
      vFences: list[int],
  ) -> int:
    hFences = sorted(hFences + [1, m])
    vFences = sorted(vFences + [1, n])
    hGaps = {hFences[i] - hFences[j]
             for i in range(len(hFences))
             for j in range(i)}
    vGaps = {vFences[i] - vFences[j]
             for i in range(len(vFences))
             for j in range(i)}
    maxGap = next((hGap
                  for hGap in sorted(hGaps, reverse=True)
                  if hGap in vGaps), -1)
    return -1 if maxGap == -1 else maxGap**2 % (10**9 + 7)
```
