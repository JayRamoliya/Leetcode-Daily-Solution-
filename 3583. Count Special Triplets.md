Here is your **GitHub-ready Markdown (`README.md`) file** for this problem and solution.
You can directly copy-paste this into your GitHub repository:

---

````md
# ğŸš€ Special Triplets in an Array (Python Solution)

This repository contains an optimized **O(n)** solution to the problem of counting **special triplets** in an integer array using **Python 3**.

---

## ğŸ“˜ Problem Statement

You are given an integer array `nums`.

A **special triplet** is defined as a triplet of indices `(i, j, k)` such that:

- `0 <= i < j < k < n`
- `nums[i] == nums[j] * 2`
- `nums[k] == nums[j] * 2`

Return the **total number of special triplets** in the array.  
Since the answer may be large, return it **modulo `10^9 + 7`**.

---

## âœ… Examples

### Example 1
**Input:**
```text
nums = [6, 3, 6]
````

**Output:**

```text
1
```

---

### Example 2

**Input:**

```text
nums = [0, 1, 0, 0]
```

**Output:**

```text
1
```

---

### Example 3

**Input:**

```text
nums = [8, 4, 2, 8, 4]
```

**Output:**

```text
2
```

---

## ğŸ§  Approach

We fix index `j` as the middle of the triplet and count:

* How many valid `i` exist **before `j`**
* How many valid `k` exist **after `j`**

For each `j`:

```
Contribution = left[nums[j] * 2] * right[nums[j] * 2]
```

We use:

* `left` â†’ frequency map of elements before `j`
* `right` â†’ frequency map of elements after `j`

---

## ğŸ§® Time & Space Complexity

| Type     | Complexity |
| -------- | ---------- |
| â± Time   | **O(n)**   |
| ğŸ’¾ Space | **O(n)**   |

---

## ğŸ§‘â€ğŸ’» Python 3 Implementation

```python
from typing import List
from collections import Counter

class Solution:
    def specialTriplets(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        
        right = Counter(nums)   # All elements initially on the right
        left = Counter()        # Empty at the start
        
        ans = 0
        
        for j in nums:
            right[j] -= 1       # Remove current j from right
            
            target = j * 2
            
            count_i = left[target]     # Valid i count
            count_k = right[target]    # Valid k count
            
            ans = (ans + count_i * count_k) % MOD
            
            left[j] += 1        # Move j to left
        
        return ans
```

---

## ğŸ Final Notes

* This solution avoids the brute-force **O(nÂ³)** approach.
* Efficient even for large inputs.
* Uses Pythonâ€™s built-in `Counter` for fast lookups.

---

### â­ If you find this helpful, please give the repo a star!

Happy Coding! ğŸš€

```

---

If you want, I can also:
âœ… Add **LeetCode-style test runner**  
âœ… Add **brute-force comparison version**  
âœ… Create **full GitHub project structure**

Just tell me! ğŸ˜Š
```
