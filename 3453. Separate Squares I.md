## 3453. Separate Squares I

### C++
```
class Solution {
 public:
  double separateSquares(vector<vector<int>>& squares) {
    const double halfArea = accumulate(squares.begin(), squares.end(), 0.0,
                                       [](double sum, vector<int>& square) {
      return sum + static_cast<long>(square[2]) * square[2];
    }) / 2;
    vector<tuple<int, bool, int>> events;

    for (const vector<int>& square : squares) {
      const int y = square[1];
      const int l = square[2];
      events.push_back({y, true, l});       // start of square
      events.push_back({y + l, false, l});  // end of square
    }

    ranges::sort(events);

    double area = 0;
    int width = 0;
    int prevY = 0;

    for (const auto& [y, isStart, l] : events) {
      double areaGain = width * static_cast<long>(y - prevY);
      if (area + areaGain >= halfArea)
        return prevY + (halfArea - area) / width;
      area += areaGain;
      width += isStart ? l : -l;
      prevY = y;
    }

    throw;
  }
```

### Python 

```
class Solution:
  def separateSquares(self, squares: list[list[int]]) -> float:
    halfArea = sum((l**2 for _, _, l in squares)) / 2
    events = sorted([(y, True, l) for _, y, l in squares] +
                    [(y + l, False, l) for _, y, l in squares])
    area = 0
    width = 0
    prevY = 0

    for y, isStart, l in events:
      areaGain = width * (y - prevY)
      if area + areaGain >= halfArea:
        return prevY + (halfArea - area) / width
      area += areaGain
      width += l if isStart else -l
      prevY = y
```
