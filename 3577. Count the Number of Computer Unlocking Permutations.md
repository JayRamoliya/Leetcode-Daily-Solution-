# ğŸ–¥ï¸ 3577. Count the Number of Computer Unlocking Permutations

**Difficulty:** Medium  
**Topics:** Dynamic Programming, Graph, Topological Sort  
**Language:** Python 3  

---

## ğŸ“˜ Problem Statement

You are given an array `complexity` of length `n`.

There are `n` locked computers in a room with labels from `0` to `n - 1`, each with its own unique password.

- The password of the computer `i` has a complexity `complexity[i]`.
- The password for the computer labeled `0` is already decrypted and serves as the **root**.
- All other computers must be unlocked using it or another previously unlocked computer.

### ğŸ”“ Unlocking Rule:

You can decrypt the password for computer `i` using the password for computer `j` if:

- `j < i`
- `complexity[j] < complexity[i]`
- Computer `j` must already be unlocked

---

## ğŸ¯ Goal

Find the **number of valid permutations** of `[0, 1, 2, ..., n - 1]` that represent a valid order in which the computers can be unlocked.

Return the result modulo **10â¹ + 7**.

> âš ï¸ Note: Computer `0` is already unlocked. It does **not** need to appear first in the permutation.

---

## âœ… Example 1

**Input:**
```text
complexity = [1, 2, 3]
````

**Output:**

```text
2
```

**Valid Orders:**

```text
[0, 1, 2]
[0, 2, 1]
```

---

## âŒ Example 2

**Input:**

```text
complexity = [3, 3, 3, 4, 4, 4]
```

**Output:**

```text
0
```

**Reason:**
No smaller-complexity computer exists to unlock the initial ones.

---

## ğŸ§  Key Observations

* Every computer `i > 0` must have **at least one valid parent**:

  * `j < i`
  * `complexity[j] < complexity[i]`
* If any computer fails this rule â†’ **Answer = 0**
* Once dependencies are valid, the problem becomes:

  > **Counting valid topological orders of a dependency graph**

---

## ğŸ§® Approach

We simulate the unlocking process step-by-step:

1. Start with `computer 0` unlocked.
2. For each computer `i`:

   * Count how many unlocked computers can unlock it.
   * Multiply this count into the result.
3. If at any step there are **0 possible parents**, return `0`.

---

## âœ… Python 3 Solution

```python
class Solution:
    def countPermutations(self, complexity: List[int]) -> int:
        MOD = 10**9 + 7
        n = len(complexity)

        dp = 1  # total ways
        unlocked = []  # list of unlocked computer indices

        for i in range(n):
            if i == 0:
                unlocked.append(i)
                continue

            valid = 0
            for j in unlocked:
                if j < i and complexity[j] < complexity[i]:
                    valid += 1

            if valid == 0:
                return 0  # impossible to unlock this computer

            dp = (dp * valid) % MOD
            unlocked.append(i)

        return dp
```

---

## ğŸ§ª Dry Run (Example 1)

| Step | Computer | Valid Parents | Ways |
| ---- | -------- | ------------- | ---- |
| 0    | 0        | root          | 1    |
| 1    | 1        | 1             | 1    |
| 2    | 2        | 2             | 2 âœ…  |

---

## â±ï¸ Complexity Analysis

* **Time Complexity:** `O(nÂ²)`
* **Space Complexity:** `O(n)`
* Can be optimized to `O(n log n)` using Fenwick Tree if required.


```

---

If you want, I can also:
âœ… Add **C++ / Java version**  
âœ… Add **optimized O(n log n)** solution  
âœ… Convert this into **LeetCode submission format**  
âœ… Make it into a **reels script (Hindi + English)**  

Just tell me ğŸ‘
```
